from SCons.Script import *
import os, sys, subprocess, re

#HACK!  Find vsim
def has_vsim (dir):
    return (os.path.exists(os.path.join(dir,'vsim')))

ospath=os.environ['PATH'].split(':')
vsimdirs=filter(has_vsim,ospath)
if len(vsimdirs) == 0:
    sys.stderr.write("Warning (modelsim.py), vsim not found in $PATH.\n")
if len(vsimdirs) > 1:
    sys.stderr.write("Warning (modelsim.py), multiple vsim executables in $PATH.  Directories containing vsim:\n")
    for p in vsimdirs:
        sys.stderr.write("\t"+p+"\n")

env = Environment(ENV = os.environ,
                  MODELSIMDIR=vsimdirs[0],
                  VLIBDIR='work',
                  VLOGFLAGS='+incdir+/home/andersoe/ovl/std_ovl/ +define+OVL_ASSERT_ON',
                  VSIMFLAGS='-novopt -do "add wave -r /*; run -all" -c -onfinish exit -lib $VLIBDIR')

# vlog_sources = Glob('*.v') + Glob('*.sv')

# test_toplevels = ['top']


# Set up modelsim
vlibdir = Dir(env.subst('$VLIBDIR'))
env.Command(vlibdir,[],"test -e $VLIBDIR  || vlib $VLIBDIR")

# Compile sources (modelsim)
env.Append(BUILDERS = {'vlog' :
                       Builder(action="vlog $VLOGFLAGS $SOURCE",
                               src_suffix=".v")})

def modelsim_compiled(name_map,srcfile):

    '''Return the name of (a) compiled file generated by vlog from a
    given source file'''

    def extract(module):
        if module['src']==srcfile:
            try:
                return module['short_name']
            except KeyError:
                return module['name']
        else:
            return None
                
            
    e = [extract(m) for m in name_map]
    matches = [name for name in e if name is not None]
    
    #print srcfile, matches
    return [env.subst('$VLIBDIR')+'/'+ m +'/_primary.dat' for m in matches]

# for srcfile in vlog_sources:
#     env.vlog(modelsim_compiled(srcfile), srcfile)


# Default([modelsim_compiled(srcfile) for srcfile in vlog_sources])


# Run simulations (modelsim -- vsim)
def generate_vsim(source,target,env,for_signature):
    top_module = str(target[0]).split('.vsim_log')[0]
    log_fname = top_module + ".vsim_log"
    wlf_fname = top_module + ".wlf"
    return ("vsim $VSIMFLAGS -l %s -wlf %s %s" %(log_fname, wlf_fname, top_module))
env.Append(BUILDERS = {'vsim' : 
                       Builder(generator=generate_vsim)})



##
## Use vdir to identify the compilations sources and targets for each module
##
MODULE_re = re.compile('^MODULE\s(.*)$')
SRC_re = re.compile('^\s+HDL source file:\s(.*)$')
SNAME_re = re.compile('^\s+Short name:\s(.*)$')

def re_match(re, str, group=0):
    m = re.match(str)
    if m:
        return m.groups()[group]
    else:
        return None
    

def map_vlib_filenames(lib="work"):
    output = subprocess.Popen([env.subst("$MODELSIMDIR/vdir"), '-lib',lib,'-l'], stdout=subprocess.PIPE).communicate()[0]
    cur_mod = None
    modules = []
    for line in output.split('\n'):
        l = line.rstrip()
        modname = re_match(MODULE_re, l)
        if modname:
            if cur_mod is None:                
                cur_mod = {'name':modname}
            else:
                modules.append(cur_mod)
                cur_mod = {'name':modname}
            continue
        fname = re_match(SRC_re, l)
        if fname:
            if cur_mod is None:
                ## This is OK, there are file name entries for things other than modules
                continue            
            cur_mod['src']=fname
            continue
        sname = re_match(SNAME_re, l)
        if sname:
            if cur_mod is None:
                continue
            else:
                cur_mod['short_name']=sname
            continue
    ## Done
    if cur_mod is not None:
        modules.append(cur_mod)
    return modules
        
